<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Melyik lehet tükörkép?</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #ffffff;
            --fg: #1a1a1a;
            --card-bg: #f9fafb;
            --border: #e0e0e0;
            --green: #22c55e;
            --green-dark: #16a34a;
            --blue: #3b82f6;
            --red: #ef4444;
            --yellow: #facc15;
            --text-muted: #757575;
            --shadow: 0 2px 4px rgba(0,0,0,0.05);
            --transition: all 0.2s ease-in-out;
        }

        html, body {
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--fg);
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 24px 16px;
            box-sizing: border-box;
        }

        .container {
            max-width: 980px;
            width: 100%;
        }

        h1 {
            font-weight: 700;
            font-size: 2rem;
            margin: 0 0 4px 0;
        }

        .subtitle {
            color: var(--text-muted);
            font-size: 1rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .card {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            background: var(--card-bg);
            box-shadow: var(--shadow);
            margin-top: 20px;
        }

        .task-title {
            font-size: 1.1rem;
            font-weight: 500;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .canvas-wrap {
            position: relative;
            border: 1px solid var(--border);
            border-radius: 10px;
            overflow: hidden;
            background: #fff;
            aspect-ratio: 940 / 500;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            max-width: 940px;
            cursor: pointer;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-top: 20px;
        }

        .feedback {
            margin-top: 12px;
            font-weight: 500;
            font-size: 0.9rem;
            min-height: 20px;
        }

        .feedback.ok { color: var(--green-dark); }
        .feedback.err { color: var(--red); }
        .feedback.info { color: var(--blue); }

        .task-toggle button {
            padding: 8px 16px;
            background: var(--bg);
            color: var(--fg);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .task-toggle button.active {
            background: var(--blue);
            color: #fff;
            border-color: var(--blue);
        }
        
        .task-toggle button:hover:not(.active) {
            border-color: var(--text-muted);
            background-color: #f5f5f5;
        }

        button.primary {
            background: var(--green);
            color: #fff;
            border: 1px solid var(--green);
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
        }

        button.primary:hover {
            background: var(--green-dark);
            border-color: var(--green-dark);
        }

        button.secondary {
            background: var(--bg);
            color: var(--fg);
            border: 1px solid var(--border);
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
        }
        
        button.secondary:hover {
            border-color: var(--text-muted);
            background-color: #f5f5f5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Melyik lehet tükörkép?</h1>
        <div class="subtitle">
            <span>Válassz feladatot:</span>
            <div class="task-toggle">
                <button id="task1Btn" class="active">Feladat 1</button>
                <button id="task2Btn">Feladat 2</button>
                <button id="task3Btn">Feladat 3</button>
            </div>
        </div>

        <div class="card">
            <h2 id="task-title" class="task-title"></h2>
            
            <div class="canvas-wrap">
                <canvas id="gameCanvas" width="940" height="500"></canvas>
            </div>

            <div class="controls">
                <button id="checkBtn" class="primary">Kész vagyok</button>
                <button id="retryBtn" class="secondary">Újra próbálom</button>
            </div>

            <div id="feedback" class="feedback info"></div>
        </div>
    </div>

    <script>
    window.onload = function() {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const feedbackEl = document.getElementById('feedback');
        const taskTitleEl = document.getElementById('task-title');
        const task1Btn = document.getElementById('task1Btn');
        const task2Btn = document.getElementById('task2Btn');
        const task3Btn = document.getElementById('task3Btn');
        const checkBtn = document.getElementById('checkBtn');
        const retryBtn = document.getElementById('retryBtn');

        let currentTask = 1;
        const margin = 20;
        
        let originalShape = null;
        let candidateShapes = [];
        let selectedIndices = new Set();
        let correctIndices = new Set();
        
        const colors = {
            red: '#ef4444',
            blue: '#3b82f6',
            green: '#22c55e',
            yellow: '#facc15',
            text: '#1a1a1a',
            line: '#333333'
        };
        
        const distSq = (p1, p2) => (p1.x - p2.x)**2 + (p1.y - p2.y)**2;

        function getShapeBounds(shape, padding = 0) {
            const points = shape.type === 'segment' ? [shape.p1, shape.p2] : shape.vertices;
            if (!points || points.length === 0) return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
            const xs = points.map(p => p.x);
            const ys = points.map(p => p.y);
            return {
                minX: Math.min(...xs) - padding,
                minY: Math.min(...ys) - padding,
                maxX: Math.max(...xs) + padding,
                maxY: Math.max(...ys) + padding
            };
        }

        function isOverlapping(newShape, existingShapes) {
            const padding = 20; // Visual separation
            const newBounds = getShapeBounds(newShape, padding);

            for (const existingShape of existingShapes) {
                const existingBounds = getShapeBounds(existingShape, padding);
                const xOverlap = newBounds.minX < existingBounds.maxX && newBounds.maxX > existingBounds.minX;
                const yOverlap = newBounds.minY < existingBounds.maxY && newBounds.maxY > existingBounds.minY;
                if (xOverlap && yOverlap) {
                    return true;
                }
            }
            return false;
        }

        function isShapeInBounds(shape, margin) {
            const bounds = getShapeBounds(shape);
            return bounds.minX >= margin && bounds.maxX <= canvas.width - margin &&
                   bounds.minY >= margin && bounds.maxY <= canvas.height - margin;
        }

        function drawShape(shape, options = {}) {
            if (!shape) return;
            if (shape.type === 'segment') drawSegment(shape, options);
            else drawPolygon(shape, options);
        }

        function drawSegment(segment, options = {}) {
            const { isOriginal = false, isSelected = false } = options;
            
            ctx.beginPath();
            ctx.moveTo(segment.p1.x, segment.p1.y);
            ctx.lineTo(segment.p2.x, segment.p2.y);
            
            ctx.lineWidth = isSelected ? 5 : 3;
            ctx.strokeStyle = isSelected ? colors.blue : colors.line;
            ctx.stroke();

            [segment.p1, segment.p2].forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 7, 0, 2 * Math.PI);
                ctx.fillStyle = p.color;
                ctx.fill();
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = colors.text;
                ctx.stroke();
            });

            if (isOriginal) {
                const padding = 15;
                const bounds = getShapeBounds(segment);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(bounds.minX-padding, bounds.minY-padding, (bounds.maxX-bounds.minX)+2*padding, (bounds.maxY-bounds.minY)+2*padding);
                ctx.setLineDash([]);
            }
        }

        function drawPolygon(shape, options = {}) {
            const { isOriginal = false, isSelected = false } = options;
            const vertices = shape.vertices;

            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for(let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();

            ctx.lineWidth = isSelected ? 5 : 3;
            ctx.strokeStyle = isSelected ? colors.blue : colors.line;
            ctx.stroke();

            vertices.forEach(v => {
                ctx.beginPath();
                ctx.arc(v.x, v.y, 7, 0, 2 * Math.PI);
                ctx.fillStyle = v.color;
                ctx.fill();
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = colors.text;
                ctx.stroke();
            });
            
            if (isOriginal) {
                const padding = 20;
                const bounds = getShapeBounds(shape);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(bounds.minX-padding, bounds.minY-padding, (bounds.maxX-bounds.minX)+2*padding, (bounds.maxY-bounds.minY)+2*padding);
                ctx.setLineDash([]);
            }
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (originalShape) {
                drawShape(originalShape, { isOriginal: true });
                candidateShapes.forEach((shape, i) => {
                    drawShape(shape, { isSelected: selectedIndices.has(i) });
                });
            }
        }

        function setupTask1() {
            currentTask = 1;
            task1Btn.classList.add('active');
            task2Btn.classList.remove('active');
            task3Btn.classList.remove('active');
            taskTitleEl.innerHTML = "A megadott szakaszt <b>középpontosan</b> tükröztük a sík egyik pontjára. Válaszd ki azokat a ponthalmazokat, amik a szakasz tükörképei lehetnek.";
            feedbackEl.textContent = 'Kattints a szakaszokra a kijöléshez.';
            feedbackEl.className = 'feedback info';
            
            selectedIndices.clear();
            correctIndices.clear();

            const p1 = { x: margin + 60, y: canvas.height / 2 + (Math.random() - 0.5) * (canvas.height * 0.4), color: colors.red };
            const p2 = { x: p1.x + 100 + Math.random() * 30, y: p1.y + (Math.random() - 0.5) * 50, color: colors.blue };
            originalShape = { type: 'segment', p1, p2 };
            
            const originalDx = p2.x - p1.x;
            const originalDy = p2.y - p1.y;
            const originalLength = Math.sqrt(originalDx**2 + originalDy**2);

            let generatedShapes = [];
            const numCorrect = 3;
            const numIncorrect = 6;

            for (let i = 0; i < numCorrect; i++) {
                let shape; let attempts = 0;
                do {
                    const shapeWidth = Math.abs(originalDx);
                    const shapeHeight = Math.abs(originalDy);
                    const xRange = (canvas.width * 0.6 - 2 * margin) - shapeWidth;
                    const yRange = canvas.height - 2 * margin - shapeHeight;

                    if (xRange <= 0 || yRange <= 0) { attempts = 100; continue; }

                    const startX = canvas.width * 0.4 + Math.random() * xRange;
                    const startY = margin + Math.random() * yRange;

                    shape = { type: 'segment', p1: { x: startX, y: startY, color: colors.blue }, p2: { x: startX + originalDx, y: startY + originalDy, color: colors.red }, isCorrect: true };
                    attempts++;
                } while ((!isShapeInBounds(shape, margin) || isOverlapping(shape, [originalShape, ...generatedShapes])) && attempts < 100);
                if (attempts < 100) generatedShapes.push(shape);
            }

            for (let i = 0; i < numIncorrect; i++) {
                let shape; let attempts = 0;
                do {
                    const startX = canvas.width * 0.35 + Math.random() * (canvas.width * 0.65 - 2 * margin);
                    const startY = margin + Math.random() * (canvas.height - 2 * margin);
                    const type = Math.floor(Math.random() * 3);
                    switch (type) {
                        case 0:
                            shape = { type: 'segment', p1: { x: startX, y: startY, color: colors.red }, p2: { x: startX + originalDx, y: startY + originalDy, color: colors.blue }};
                            break;
                        case 1:
                            const angle = Math.random() * 2 * Math.PI;
                            shape = { type: 'segment', p1: { x: startX, y: startY, color: colors.red }, p2: { x: startX + Math.cos(angle) * originalLength, y: startY + Math.sin(angle) * originalLength, color: colors.blue }};
                            break;
                        case 2:
                            const lengthModifier = (Math.random() > 0.5) ? 1.5 : 0.6;
                            shape = { type: 'segment', p1: { x: startX, y: startY, color: colors.red }, p2: { x: startX + originalDx * lengthModifier, y: startY + originalDy * lengthModifier, color: colors.blue }};
                            break;
                    }
                    shape.isCorrect = false;
                    attempts++;
                } while ((!isShapeInBounds(shape, margin) || isOverlapping(shape, [originalShape, ...generatedShapes])) && attempts < 100);
                if (attempts < 100) generatedShapes.push(shape);
            }

            candidateShapes = generatedShapes.sort(() => Math.random() - 0.5);
            candidateShapes.forEach((shape, index) => { if (shape.isCorrect) correctIndices.add(index); });
            redrawCanvas();
        }

        function setupTask2() {
            currentTask = 2;
            task1Btn.classList.remove('active');
            task2Btn.classList.add('active');
            task3Btn.classList.remove('active');
            taskTitleEl.innerHTML = "A megadott derékszögű háromszöget <b>középpontosan</b> tükröztük a sík egyik pontjára. Válaszd ki azokat a ponthalmazokat, amik a háromszög tükörképei lehetnek.";
            feedbackEl.textContent = 'Kattints a háromszögekre a kijelöléshez.';
            feedbackEl.className = 'feedback info';

            selectedIndices.clear();
            correctIndices.clear();
            
            const v1 = { x: margin + 60, y: canvas.height / 2 + (Math.random() - 0.5) * (canvas.height * 0.3), color: colors.red };
            const leg1Len = 80 + Math.random() * 40;
            const leg2Len = 80 + Math.random() * 40;
            const v2 = { x: v1.x + leg1Len, y: v1.y, color: colors.blue };
            const v3 = { x: v1.x, y: v1.y + leg2Len, color: colors.green };
            originalShape = { type: 'triangle', vertices: [v1, v2, v3] };
            
            let generatedShapes = [];
            const numCorrect = 3;
            const numIncorrect = 6;
            
            for (let i = 0; i < numCorrect; i++) {
                let shape; let attempts = 0;
                do {
                    const center = {
                        x: canvas.width * (0.45 + Math.random() * 0.1),
                        y: canvas.height * (0.5 + (Math.random() - 0.5) * 0.4)
                    };
                    const newV1 = { x: 2 * center.x - v1.x, y: 2 * center.y - v1.y, color: v1.color };
                    const newV2 = { x: 2 * center.x - v2.x, y: 2 * center.y - v2.y, color: v2.color };
                    const newV3 = { x: 2 * center.x - v3.x, y: 2 * center.y - v3.y, color: v3.color };
                    shape = { type: 'triangle', vertices: [newV1, newV2, newV3], isCorrect: true };
                    attempts++;
                } while ((!isShapeInBounds(shape, margin) || isOverlapping(shape, [originalShape, ...generatedShapes])) && attempts < 100);
                if (attempts < 100) generatedShapes.push(shape);
            }

             for (let i = 0; i < numIncorrect; i++) {
                let shape; let attempts = 0;
                do {
                    const bounds = getShapeBounds(originalShape);
                    const shapeWidth = bounds.maxX - bounds.minX;
                    const shapeHeight = bounds.maxY - bounds.minY;
                    const xRange = canvas.width * 0.5 - margin - shapeWidth;
                    const yRange = canvas.height - 2*margin - shapeHeight;
                    
                    if (xRange <=0 || yRange <=0) { attempts = 100; continue; }

                    const startX = canvas.width * 0.5 + Math.random() * xRange;
                    const startY = margin + Math.random() * yRange;

                    const type = Math.floor(Math.random() * 5);
                    let newV1, newV2, newV3;
                    const vec12 = {x: v2.x - v1.x, y: v2.y - v1.y};
                    const vec13 = {x: v3.x - v1.x, y: v3.y - v1.y};
                    switch (type) {
                        case 0: // Translation
                            newV1 = { x: startX, y: startY, color: v1.color };
                            newV2 = { x: startX + vec12.x, y: startY + vec12.y, color: v2.color };
                            newV3 = { x: startX + vec13.x, y: startY + vec13.y, color: v3.color };
                            shape = { type: 'triangle', vertices: [newV1, newV2, newV3] };
                            break;
                        case 1: // Scaled
                            const scale = (Math.random() > 0.5) ? 1.4 : 0.6;
                            newV1 = { x: startX, y: startY, color: v1.color };
                            newV2 = { x: startX + vec12.x * scale, y: startY + vec12.y * scale, color: v2.color };
                            newV3 = { x: startX + vec13.x * scale, y: startY + vec13.y * scale, color: v3.color };
                            shape = { type: 'triangle', vertices: [newV1, newV2, newV3] };
                            break;
                        case 2: // Rotated
                            const angle = (Math.PI / 2) * (Math.random() > 0.5 ? 1 : -1);
                            const cosA = Math.cos(angle); const sinA = Math.sin(angle);
                            newV1 = { x: startX, y: startY, color: v1.color };
                            newV2 = { x: startX + vec12.x * cosA - vec12.y * sinA, y: startY + vec12.x * sinA + vec12.y * cosA, color: v2.color };
                            newV3 = { x: startX + vec13.x * cosA - vec13.y * sinA, y: startY + vec13.x * sinA + vec13.y * cosA, color: v3.color };
                            shape = { type: 'triangle', vertices: [newV1, newV2, newV3] };
                            break;
                        case 3: // Reflected
                             newV1 = { x: startX, y: startY, color: v1.color };
                             newV2 = { x: startX + vec12.x, y: startY - vec12.y, color: v2.color };
                             newV3 = { x: startX + vec13.x, y: startY - vec13.y, color: v3.color };
                             shape = { type: 'triangle', vertices: [newV1, newV2, newV3] };
                             break;
                        case 4: // Distorted
                             newV1 = { x: startX, y: startY, color: v1.color };
                             newV2 = { x: startX + vec12.x, y: startY + vec12.y, color: v2.color };
                             newV3 = { x: startX + vec13.x + (Math.random() - 0.5) * 120, y: startY + vec13.y + (Math.random() - 0.5) * 120, color: v3.color };
                             shape = { type: 'triangle', vertices: [newV1, newV2, newV3] };
                             break;
                    }
                    shape.isCorrect = false;
                    attempts++;
                } while ((!isShapeInBounds(shape, margin) || isOverlapping(shape, [originalShape, ...generatedShapes])) && attempts < 100);
                if (attempts < 100) generatedShapes.push(shape);
            }

            candidateShapes = generatedShapes.sort(() => Math.random() - 0.5);
            candidateShapes.forEach((shape, index) => { if (shape.isCorrect) correctIndices.add(index); });
            redrawCanvas();
        }

        function setupTask3() {
            currentTask = 3;
            task1Btn.classList.remove('active');
            task2Btn.classList.remove('active');
            task3Btn.classList.add('active');
            taskTitleEl.innerHTML = "A megadott parallelogrammát <b>tengelyesen</b> tükröztük. Válaszd ki azokat a ponthalmazokat, amik a parallelogramma tükörképei lehetnek.";
            feedbackEl.textContent = 'Kattints az alakzatokra a kijelöléshez.';
            feedbackEl.className = 'feedback info';

            selectedIndices.clear();
            correctIndices.clear();

            const s = Math.min(canvas.width, canvas.height) / 1000;
            const v1 = { x: margin + 100 * s, y: canvas.height / 2 + 50 * s, color: colors.red };
            const v2 = { x: v1.x + 100 * s, y: v1.y - 40 * s, color: colors.blue };
            const v4 = { x: v1.x - 30 * s, y: v1.y - 60 * s, color: colors.yellow };
            const v3 = { x: v2.x + (v4.x - v1.x), y: v2.y + (v4.y - v1.y), color: colors.green };
            originalShape = { type: 'parallelogram', vertices: [v1, v2, v3, v4] };

            let generatedShapes = [];
            const numCorrect = 2;
            const numIncorrect = 7;

            const reflectPointOverLine = (point, line) => {
                const a = line.m; const b = -1; const c = line.c;
                const den = a * a + b * b;
                if (den === 0) return point;
                const num = a * point.x + b * point.y + c;
                return { x: point.x - 2 * a * num / den, y: point.y - 2 * b * num / den, color: point.color };
            };
            
            let correctShapesGenerated = 0;
            let totalAttempts = 0;

            while (correctShapesGenerated < numCorrect && totalAttempts < 5000) {
                let m;
                const slopeType = Math.random();
                if (slopeType < 0.7) {
                    m = (Math.random() * 4 - 2); 
                    if (Math.abs(m) < 0.3) m = (m >= 0 ? 1 : -1) * 0.3;
                } else {
                    m = (Math.random() * 8 - 4);
                    if (Math.abs(m) < 2) m = (m >= 0 ? 1 : -1) * 2;
                }

                const c_center = (canvas.height / 2) - m * (canvas.width / 2);
                const c = c_center + (Math.random() - 0.5) * (canvas.height * 0.7);
                
                const line = { m, c };
                const newVertices = originalShape.vertices.map(v => reflectPointOverLine(v, line));
                const shape = { type: 'parallelogram', vertices: newVertices, isCorrect: true };
                
                if (isShapeInBounds(shape, margin) && !isOverlapping(shape, [originalShape, ...generatedShapes])) {
                    generatedShapes.push(shape);
                    correctShapesGenerated++;
                }
                totalAttempts++;
            }

            for (let i = 0; i < numIncorrect; i++) {
                let shape; let attempts = 0;
                do {
                    const bounds = getShapeBounds(originalShape);
                    const shapeWidth = bounds.maxX - bounds.minX;
                    const shapeHeight = bounds.maxY - bounds.minY;
                    const xRange = canvas.width * 0.6 - margin - shapeWidth;
                    const yRange = canvas.height - 2*margin - shapeHeight;

                    if (xRange <= 0 || yRange <=0) { attempts = 100; continue; }

                    const startX = canvas.width * 0.4 + Math.random() * xRange;
                    const startY = margin + Math.random() * yRange;
                    
                    const type = Math.floor(Math.random() * 5);
                    let newVertices;
                    const [ov1, ov2, ov3, ov4] = originalShape.vertices;

                    switch (type) {
                        case 0: // Point Reflection
                            const center = { x: startX + 60*s, y: startY + 60*s};
                            newVertices = originalShape.vertices.map(v => ({ x: 2 * center.x - v.x, y: 2 * center.y - v.y, color: v.color }));
                            break;
                        case 1: // Incorrect colors
                            const line = { m: 1000, c: -1000 * (canvas.width / 2 + (Math.random() - 0.5) * 50) };
                            newVertices = originalShape.vertices.map(v => reflectPointOverLine(v, line));
                            [newVertices[1].color, newVertices[3].color] = [newVertices[3].color, newVertices[1].color];
                            break;
                        case 2: // Scaled
                            const scale = 1.5;
                            const newV1_s = { x: startX, y: startY, color: ov1.color };
                            newVertices = [ newV1_s,
                                { x: newV1_s.x + (ov2.x - ov1.x) * scale, y: newV1_s.y + (ov2.y - ov1.y) * scale, color: ov2.color },
                                { x: newV1_s.x + (ov3.x - ov1.x) * scale, y: newV1_s.y + (ov3.y - ov1.y) * scale, color: ov3.color },
                                { x: newV1_s.x + (ov4.x - ov1.x) * scale, y: newV1_s.y + (ov4.y - ov1.y) * scale, color: ov4.color } ];
                            break;
                        case 3: // Rectangle
                            newVertices = [ { x: startX, y: startY, color: ov1.color }, { x: startX + 84*s, y: startY, color: ov2.color },
                                { x: startX + 84*s, y: startY + 56*s, color: ov3.color }, { x: startX, y: startY + 56*s, color: ov4.color } ];
                            break;
                        case 4: // Translation
                            newVertices = originalShape.vertices.map(v => ({x: v.x + canvas.width * 0.3 + Math.random() * 50, y: v.y + (Math.random() - 0.5) * 50, color: v.color}));
                            break;
                    }
                    shape = { type: 'parallelogram', vertices: newVertices, isCorrect: false };
                    attempts++;
                } while ((!isShapeInBounds(shape, margin) || isOverlapping(shape, [originalShape, ...generatedShapes])) && attempts < 100);
                if (attempts < 100) generatedShapes.push(shape);
            }

            candidateShapes = generatedShapes.sort(() => Math.random() - 0.5);
            candidateShapes.forEach((shape, index) => { if (shape.isCorrect) correctIndices.add(index); });
            redrawCanvas();
        }

        function checkAnswer() {
            if (selectedIndices.size === 0) {
                feedbackEl.textContent = 'Jelölj ki legalább egy alakzatot!';
                feedbackEl.className = 'feedback info';
                return;
            }
            let hasIncorrectSelection = false;
            for (const idx of selectedIndices) {
                if (!candidateShapes[idx].isCorrect) {
                    hasIncorrectSelection = true;
                    break;
                }
            }
            if (hasIncorrectSelection) {
                feedbackEl.textContent = 'Olyan alakzatot is kijelöltél, ami nem tükörkép!';
                feedbackEl.className = 'feedback err';
                return;
            }
            if (selectedIndices.size === correctIndices.size) {
                 feedbackEl.textContent = 'Gratulálok, az összes lehetőséget megtaláltad!';
                 feedbackEl.className = 'ok';
            } else {
                 feedbackEl.textContent = 'Van még olyan alakzat, ami tükörkép!';
                 feedbackEl.className = 'info';
            }
        }
        
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickPoint = { 
                x: (event.clientX - rect.left) * scaleX, 
                y: (event.clientY - rect.top) * scaleY
            };
            
            candidateShapes.forEach((shape, i) => {
                let wasClicked = false;
                if (shape.type === 'segment') {
                    const lenSq = distSq(shape.p1, shape.p2);
                    if (lenSq === 0) return;
                    let t = ((clickPoint.x - shape.p1.x) * (shape.p2.x - shape.p1.x) + (clickPoint.y - shape.p1.y) * (shape.p2.y - shape.p1.y)) / lenSq;
                    t = Math.max(0, Math.min(1, t));
                    const closestPoint = { x: shape.p1.x + t * (shape.p2.x - shape.p1.x), y: shape.p1.y + t * (shape.p2.y - shape.p1.y) };
                    if (distSq(clickPoint, closestPoint) < 15*15) wasClicked = true;
                } else if (shape.vertices && shape.vertices.length >= 3) {
                    const vertices = shape.vertices;
                    let signs = [];
                    for (let j = 0; j < vertices.length; j++) {
                        const p1 = vertices[j];
                        const p2 = vertices[(j + 1) % vertices.length];
                        const sign = (p2.x - p1.x) * (clickPoint.y - p1.y) - (p2.y - p1.y) * (clickPoint.x - p1.x);
                        signs.push(sign);
                    }
                    if (signs.every(s => s >= 0) || signs.every(s => s <= 0)) {
                        wasClicked = true;
                    }
                }

                if (wasClicked) {
                    if (selectedIndices.has(i)) selectedIndices.delete(i);
                    else selectedIndices.add(i);
                }
            });
            redrawCanvas();
        }
        
        let resizeTimer;
        function debounce(func, time) {
            return function(event) {
                if (resizeTimer) clearTimeout(resizeTimer);
                resizeTimer = setTimeout(func, time, event);
            };
        }

        function resizeCanvasAndSetup() {
            const containerWidth = canvas.parentElement.clientWidth;
            const aspectRatio = 500 / 940;
            
            canvas.width = Math.min(containerWidth, 940);
            canvas.height = canvas.width * aspectRatio;
            
            if (currentTask === 1) setupTask1();
            else if (currentTask === 2) setupTask2();
            else if (currentTask === 3) setupTask3();
        }

        task1Btn.addEventListener('click', () => { currentTask = 1; resizeCanvasAndSetup(); });
        task2Btn.addEventListener('click', () => { currentTask = 2; resizeCanvasAndSetup(); });
        task3Btn.addEventListener('click', () => { currentTask = 3; resizeCanvasAndSetup(); });

        checkBtn.addEventListener('click', checkAnswer);
        retryBtn.addEventListener('click', resizeCanvasAndSetup);
        canvas.addEventListener('click', handleCanvasClick);
        
        resizeCanvasAndSetup();
        window.addEventListener('resize', debounce(resizeCanvasAndSetup, 150));
    };
    </script>
</body>
</html>